<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <title>JS Fractal Prototype</title>
    <script type="text/javascript" src="lib/mootools.js"></script>
    <script type="text/javascript">

        var JSFractal = new Class({

            /*
             * Configuration
             */
            NUM_TESTS: 25,
            PLANE_COORDS: {
                x: [-2.1, 0.9],
                y: [-1.5, 1.5],
                ax: [-1.4, -0.4],
                ay: [-0.5, 0.5]
            },
            GRID_SIZE: 4,

            /*
             * Members
             */
            elm_canvas: null,
            obj_canvas_ctx: null,

            int_screen_width: null,
            int_screen_height: null,
            int_plane_x_size: null,
            int_plane_y_size: null,
            int_convert_x_ratio: null,
            int_convert_y_ratio: null,

            // drag selection element and drag object
            elm_select: null,
            obj_drag: null,

            // stores a lookup of colours for non-Mandelbrot points (depending on escape speed)
            arr_colours: null,

            // stores when a render was started so we can return the time taken once completed
            int_start_time: null,

            initialize: function(str_canvas_id) {

                // store canvas and drawing context reference
                this.elm_canvas = $(str_canvas_id);
                this.obj_canvas_ctx = this.elm_canvas.getContext('2d');
                
                // pre-calculate some values for optimisation
                this.int_screen_width = this.elm_canvas.width / this.GRID_SIZE;
                this.int_screen_height = this.elm_canvas.height / this.GRID_SIZE;
                this.int_plane_x_size = Math.abs(this.PLANE_COORDS.x[1] - this.PLANE_COORDS.x[0]);
                this.int_plane_y_size = Math.abs(this.PLANE_COORDS.y[1] - this.PLANE_COORDS.y[0]);
                this.int_convert_x_ratio = this.int_screen_width / this.int_plane_x_size;
                this.int_convert_y_ratio = this.int_screen_height / this.int_plane_y_size;

                // pre-calculate colour table for non-Mandelbrot points
                var obj_colour = new Color('#0f0');
                obj_colour.setBrightness(100);
                this.arr_colours = new Array();

                for(var i = 0; i < this.NUM_TESTS; i++) {
                    this.arr_colours[i] = 'rgb(' + new Color('#0f0').setBrightness((i*4)) + ')';
                }

                this.elm_canvas.addEvent('mousedown', function(obj_event) {

                    var obj_event = new Event(obj_event);

                    // create drag selection element
                    this.elm_select = new Element('div', {
                        styles: {
                            position: 'absolute',
                            border: '1px solid red',
                            top: obj_event.client.y,
                            left: obj_event.client.x,
                            width: 0,
                            height: 0
                        }
                    });

                    this.elm_select.injectInside($E('body'));
                    this.elm_select.makeResizable({
                        
                        onDrag: function(elm_select) {

                            var size = elm_select.getCoordinates();
    
                            if(size.width > size.height) {
                                elm_select.setStyle('width', size.height);
                            }
                            else if(size.height > size.width) {
                                elm_select.setStyle('height', size.width);
                            }
                        },
    
                        onComplete: function(elm_select) {

                            var offset_x = $('canvas').getTop();
                            var offset_y = $('canvas').getLeft();
                            var coords = elm_select.getCoordinates()
                            
                            var x0 = (coords.left - offset_x) / HACK.GRID_SIZE;
                            var y0 = (coords.top - offset_y) / HACK.GRID_SIZE;

                            var x1 = (x0 + coords.width) / HACK.GRID_SIZE;
                            var y1 = (y0 + coords.height) / HACK.GRID_SIZE;
y1 - y1 * -1;
                            console.info('(' + x0 + ', ' + y0 + ') to (' + x1 + ', ' + y1 + ')');
                            
                            // calculate new plane coords
                            var newcoords = {
                                x: [HACK.PLANE_COORDS.x[0] + ((HACK.int_plane_x_size / HACK.int_screen_width) * x0), HACK.PLANE_COORDS.x[0] + ((HACK.int_plane_x_size / HACK.int_screen_width) * x1)],
                                y: [HACK.PLANE_COORDS.y[0] + ((HACK.int_plane_y_size / HACK.int_screen_height) * y0), HACK.PLANE_COORDS.y[0] + ((HACK.int_plane_y_size / HACK.int_screen_height) * y1)]
                            };

                            HACK.PLANE_COORDS = newcoords;
                            HACK.int_plane_x_size = Math.abs(HACK.PLANE_COORDS.x[1] - HACK.PLANE_COORDS.x[0]);
                            HACK.int_plane_y_size = Math.abs(HACK.PLANE_COORDS.y[1] - HACK.PLANE_COORDS.y[0]);
                            HACK.int_convert_x_ratio = HACK.int_screen_width / HACK.int_plane_x_size;
                            HACK.int_convert_y_ratio = HACK.int_screen_height / HACK.int_plane_y_size;
                            
                            console.info(newcoords);
                            HACK.render();
                        }
                        
                    });

                    this.elm_select.fireEvent('mousedown', obj_event);

                });

                this.elm_canvas.addEvent('mouseup', function() {
                    
                });


            },

            render: function(int_y_start) {

                if(!int_y_start) {
                    int_y_start = 0;
                    this.int_start_time = $time();
                }

                var int_start_time = $time();
            
                for(var int_y = int_y_start; int_y < this.int_screen_height; ++int_y) {

                    // we've processed a row, do we now need to take a break to give the browser UI a chance to update?
                    if(($time() - int_start_time) > 5000) {
                        console.info('Taking a break on row: ' + int_y);
                        this.render.delay(1, this, int_y);
                        return;
                    }

                    for(var int_x = 0; int_x < this.int_screen_width; ++int_x) {
                    
                        var plane_x = this.PLANE_COORDS.x[0] + (int_x / this.int_convert_x_ratio);
                        //var plane_y = this.PLANE_COORDS.y[1] - (int_y / this.int_convert_y_ratio);
                        var plane_y = (this.PLANE_COORDS.y[0] + (int_y / this.int_convert_y_ratio)) * -1;

                        // calculate iterations
                        var z_x = plane_x;
                        var z_y = plane_y;
                        var boo_in_set = true;
                        
                        for(var i = 0; i < this.NUM_TESTS; ++i) {

                            var int_z_x_squared = z_x * z_x;
                            var int_z_y_squared = z_y * z_y;

                            if(int_z_x_squared + int_z_y_squared > 4) {

                                boo_in_set = false;
                                break;
                            }

                            // calculate next values of z
                            z_y = 2 * z_x * z_y + plane_y;
                            z_x = int_z_x_squared - int_z_y_squared + plane_x;         
                        }
                        
                        // is it in the set?
                        if(boo_in_set) {
                            this.obj_canvas_ctx.fillStyle = 'black';
                        }
                        else {
                            this.obj_canvas_ctx.fillStyle = this.arr_colours[i];
                        }
                            
                        // plot the point
                        this.obj_canvas_ctx.fillRect(int_x * this.GRID_SIZE, int_y * this.GRID_SIZE, this.GRID_SIZE, this.GRID_SIZE);
                    }
                }

                // we've completed the render - fire completion event, passing the time taken
                this.fireEvent('onComplete', ($time() - this.int_start_time));
            },

            drag_start: function(obj_event) {
                
                var obj_event = new Event(obj_event);

                
            }

        });

        JSFractal.implement(new Events);

        var HACK;
        window.addEvent('domready', function() {

            var obj_fractal = HACK = new JSFractal('canvas');
            obj_fractal.addEvent('onComplete', function(int_duration) { console.info('Render complete in: ' + int_duration + 'ms'); });

            obj_fractal.render();
        });


        

    </script>
    <style type="text/css">

        canvas {
            border: 1px solid black; 
        }

        selection {
            border: 1px solid white;
        }

    </style>
</head>
<body>
    <canvas id="canvas" width="300" height="300"></canvas>
</body>
</html>
